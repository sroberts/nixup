#!/usr/bin/env bash
# NixOS configuration generator module for nixup installer

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="${SCRIPT_DIR}/../lib"
CONFIG_DIR="${SCRIPT_DIR}/../config"

# shellcheck source=../lib/logging.sh
source "${LIB_DIR}/logging.sh"
# shellcheck source=../lib/utils.sh
source "${LIB_DIR}/utils.sh"

# Generate hardware-configuration.nix
generate_hardware_configuration() {
    log_info "Generating hardware configuration..."

    # Use nixos-generate-config to create base hardware config
    nixos-generate-config --root /mnt

    log_success "Hardware configuration generated"
}

# Generate the main configuration.nix
generate_configuration_nix() {
    local target_dir="/mnt/etc/nixos"
    local config_file="${target_dir}/configuration.nix"

    log_info "Generating NixOS configuration..."

    # Import variables from other modules
    local hostname="${HOSTNAME:-nixos}"
    local username="${USERNAME:-user}"
    local user_fullname="${USER_FULLNAME:-$username}"
    local user_password="${USER_PASSWORD:-}"
    local locale="${LOCALE:-en_US.UTF-8}"
    local keyboard="${KEYBOARD_LAYOUT:-us}"

    # Generate password hash
    local password_hash=""
    if [[ -n "$user_password" ]]; then
        password_hash=$(echo "$user_password" | mkpasswd -m sha-512 -s)
    fi

    # Create configuration.nix
    cat > "$config_file" << EOF
# NixOS configuration generated by nixup
# Edit this file to customize your system.
{ config, pkgs, lib, ... }:

{
  imports = [
    ./hardware-configuration.nix
    ./modules/base.nix
    ./modules/shell.nix
    ./modules/applications.nix
    ./modules/niri.nix
    ./modules/hardware-custom.nix
  ];

  # System hostname
  networking.hostName = "${hostname}";

  # Localization (timezone handled by automatic-timezoned in base.nix)
  i18n.defaultLocale = "${locale}";
  i18n.extraLocaleSettings = {
    LC_ADDRESS = "${locale}";
    LC_IDENTIFICATION = "${locale}";
    LC_MEASUREMENT = "${locale}";
    LC_MONETARY = "${locale}";
    LC_NAME = "${locale}";
    LC_NUMERIC = "${locale}";
    LC_PAPER = "${locale}";
    LC_TELEPHONE = "${locale}";
    LC_TIME = "${locale}";
  };

  # Console and keyboard
  console.keyMap = "${keyboard}";

  # User account
  users.users.${username} = {
    isNormalUser = true;
    description = "${user_fullname}";
    extraGroups = [ "wheel" "networkmanager" "video" "audio" "input" "docker" ];
    hashedPassword = "${password_hash}";
    shell = pkgs.zsh;
  };

  # Allow wheel group to use sudo
  security.sudo.wheelNeedsPassword = true;
}
EOF

    log_success "configuration.nix generated"
}

# Copy module configurations
copy_module_configs() {
    local target_dir="/mnt/etc/nixos/modules"

    log_info "Copying NixOS modules..."

    ensure_dir "$target_dir"

    # Copy base system config
    cp "${CONFIG_DIR}/system/base.nix" "${target_dir}/base.nix"

    # Copy shell config
    cp "${CONFIG_DIR}/system/shell.nix" "${target_dir}/shell.nix"

    # Copy applications config
    cp "${CONFIG_DIR}/system/applications.nix" "${target_dir}/applications.nix"

    # Copy Niri config
    cp "${CONFIG_DIR}/niri/niri.nix" "${target_dir}/niri.nix"

    # Generate hardware-specific config
    generate_hardware_custom_nix "${target_dir}/hardware-custom.nix"

    log_success "NixOS modules copied"
}

# Generate hardware-custom.nix based on detected hardware
generate_hardware_custom_nix() {
    local output_file="$1"

    log_info "Generating custom hardware configuration..."

    cat > "$output_file" << 'HEADER'
# Custom hardware configuration generated by nixup
# Based on detected hardware
{ config, pkgs, lib, ... }:

{
HEADER

    # CPU microcode
    case "${CPU_VENDOR:-}" in
        intel)
            cat >> "$output_file" << 'EOF'
  # Intel CPU
  hardware.cpu.intel.updateMicrocode = true;

EOF
            ;;
        amd)
            cat >> "$output_file" << 'EOF'
  # AMD CPU
  hardware.cpu.amd.updateMicrocode = true;

EOF
            ;;
    esac

    # GPU configuration
    case "${GPU_VENDOR:-}" in
        intel)
            cat >> "$output_file" << 'EOF'
  # Intel Graphics
  hardware.graphics = {
    enable = true;
    extraPackages = with pkgs; [
      intel-media-driver
      vaapiIntel
      vaapiVdpau
      libvdpau-va-gl
    ];
  };

EOF
            ;;
        amd)
            cat >> "$output_file" << 'EOF'
  # AMD Graphics
  hardware.graphics = {
    enable = true;
    extraPackages = with pkgs; [
      amdvlk
    ];
  };

EOF
            ;;
    esac

    # Laptop configuration
    if [[ "${IS_LAPTOP:-false}" == "true" ]]; then
        cat >> "$output_file" << 'EOF'
  # Laptop power management
  services.thermald.enable = true;
  powerManagement.enable = true;

  # Lid switch behavior
  services.logind = {
    lidSwitch = "suspend";
    lidSwitchExternalPower = "ignore";
    lidSwitchDocked = "ignore";
  };

EOF
    fi

    # Framework-specific configuration
    if [[ "${IS_FRAMEWORK:-false}" == "true" ]]; then
        cat >> "$output_file" << 'EOF'
  # Framework laptop specific
  hardware.framework.enableKmod = true;

  # Framework firmware updates
  services.fwupd.enable = true;

  # Ambient light sensor
  hardware.sensor.iio.enable = true;

  # TLP for better power management
  services.tlp = {
    enable = true;
    settings = {
      CPU_SCALING_GOVERNOR_ON_AC = "performance";
      CPU_SCALING_GOVERNOR_ON_BAT = "powersave";
      CPU_ENERGY_PERF_POLICY_ON_AC = "performance";
      CPU_ENERGY_PERF_POLICY_ON_BAT = "power";
      PLATFORM_PROFILE_ON_AC = "performance";
      PLATFORM_PROFILE_ON_BAT = "low-power";
    };
  };
  services.power-profiles-daemon.enable = false;

EOF
    fi

    # Fingerprint reader
    if [[ "${HAS_FINGERPRINT:-false}" == "true" ]]; then
        cat >> "$output_file" << 'EOF'
  # Fingerprint reader
  services.fprintd.enable = true;
  security.pam.services.login.fprintAuth = true;
  security.pam.services.sudo.fprintAuth = true;

EOF
    fi

    # Bluetooth
    if [[ "${HAS_BLUETOOTH:-true}" == "true" ]]; then
        cat >> "$output_file" << 'EOF'
  # Bluetooth
  hardware.bluetooth = {
    enable = true;
    powerOnBoot = true;
    settings = {
      General = {
        Enable = "Source,Sink,Media,Socket";
        Experimental = true;
      };
    };
  };
  services.blueman.enable = true;

EOF
    fi

    # LUKS encryption configuration
    if [[ "${USE_ENCRYPTION:-false}" == "true" && -n "${LUKS_DEVICE:-}" ]]; then
        # Get the UUID of the encrypted partition
        local crypt_uuid
        crypt_uuid=$(blkid -s UUID -o value "$LUKS_DEVICE" 2>/dev/null || echo "")

        if [[ -n "$crypt_uuid" ]]; then
            cat >> "$output_file" << EOF
  # LUKS encryption
  boot.initrd.luks.devices = {
    cryptroot = {
      device = "/dev/disk/by-uuid/${crypt_uuid}";
      preLVM = true;
      allowDiscards = true;
    };
  };

EOF
        else
            log_warn "Could not determine UUID for LUKS device: $LUKS_DEVICE"
        fi
    fi

    # Close the configuration
    cat >> "$output_file" << 'EOF'
  # Firmware
  hardware.enableRedistributableFirmware = true;
  hardware.enableAllFirmware = true;
}
EOF

    log_success "Custom hardware configuration generated"
}

# Setup user home configuration
setup_home_config() {
    local username="${USERNAME:-user}"
    local home_dir="/mnt/home/${username}"
    local config_dir="${home_dir}/.config"

    log_info "Setting up user home configuration..."

    ensure_dir "${config_dir}"

    # Copy Niri config
    ensure_dir "${config_dir}/niri"
    ensure_dir "${config_dir}/waybar"
    ensure_dir "${config_dir}/mako"
    ensure_dir "${config_dir}/fuzzel"
    ensure_dir "${config_dir}/alacritty"
    ensure_dir "${config_dir}/swaylock"

    # Extract configs from the home-manager template
    # For now, create them directly

    # Niri config
    cat > "${config_dir}/niri/config.kdl" << 'EOF'
// Niri Configuration
// See https://github.com/YaLTeR/niri/wiki/Configuration

input {
    keyboard {
        xkb {
            layout "us"
        }
        repeat-delay 300
        repeat-rate 50
    }

    touchpad {
        tap
        dwt
        natural-scroll
        accel-speed 0.2
    }

    mouse {
        accel-speed 0.0
    }

    focus-follows-mouse max-scroll-amount="25%"
}

layout {
    gaps 8
    default-column-width { proportion 0.5; }

    border {
        width 2
        active-color "#7aa2f7"
        inactive-color "#414868"
    }

    focus-ring {
        off
    }

    preset-column-widths {
        proportion 0.33333
        proportion 0.5
        proportion 0.66667
        proportion 1.0
    }
}

cursor {
    xcursor-theme "Adwaita"
    xcursor-size 24
}

screenshot-path "~/Pictures/Screenshots/%Y-%m-%d_%H-%M-%S.png"

spawn-at-startup "waybar"
spawn-at-startup "mako"

prefer-no-csd

hotkey-overlay {
    skip-at-startup
}

binds {
    Mod+Return { spawn "ghostty"; }
    Mod+Space { spawn "fuzzel"; }
    Mod+E { spawn "ghostty" "-e" "yazi"; }
    Mod+Q { close-window; }
    Mod+Shift+Q { quit; }
    Mod+L { spawn "swaylock"; }
    Mod+Escape { spawn "power-menu"; }

    Print { screenshot; }
    Mod+Print { screenshot-screen; }
    Mod+Shift+Print { screenshot-window; }

    Mod+Left  { focus-column-left; }
    Mod+Down  { focus-window-down; }
    Mod+Up    { focus-window-up; }
    Mod+Right { focus-column-right; }
    Mod+H { focus-column-left; }
    Mod+J { focus-window-down; }
    Mod+K { focus-window-up; }
    Mod+Semicolon { focus-column-right; }

    Mod+Shift+Left  { move-column-left; }
    Mod+Shift+Down  { move-window-down; }
    Mod+Shift+Up    { move-window-up; }
    Mod+Shift+Right { move-column-right; }
    Mod+Shift+H { move-column-left; }
    Mod+Shift+J { move-window-down; }
    Mod+Shift+K { move-window-up; }
    Mod+Shift+Semicolon { move-column-right; }

    Mod+1 { focus-workspace 1; }
    Mod+2 { focus-workspace 2; }
    Mod+3 { focus-workspace 3; }
    Mod+4 { focus-workspace 4; }
    Mod+5 { focus-workspace 5; }
    Mod+6 { focus-workspace 6; }
    Mod+7 { focus-workspace 7; }
    Mod+8 { focus-workspace 8; }
    Mod+9 { focus-workspace 9; }

    Mod+Shift+1 { move-column-to-workspace 1; }
    Mod+Shift+2 { move-column-to-workspace 2; }
    Mod+Shift+3 { move-column-to-workspace 3; }
    Mod+Shift+4 { move-column-to-workspace 4; }
    Mod+Shift+5 { move-column-to-workspace 5; }
    Mod+Shift+6 { move-column-to-workspace 6; }
    Mod+Shift+7 { move-column-to-workspace 7; }
    Mod+Shift+8 { move-column-to-workspace 8; }
    Mod+Shift+9 { move-column-to-workspace 9; }

    Mod+R { switch-preset-column-width; }
    Mod+Minus { set-column-width "-10%"; }
    Mod+Equal { set-column-width "+10%"; }
    Mod+F { maximize-column; }
    Mod+Shift+F { fullscreen-window; }
    Mod+C { consume-window-into-column; }
    Mod+X { expel-window-from-column; }

    Mod+Page_Down { focus-workspace-down; }
    Mod+Page_Up { focus-workspace-up; }

    XF86AudioRaiseVolume allow-when-locked=true { spawn "pamixer" "-i" "5"; }
    XF86AudioLowerVolume allow-when-locked=true { spawn "pamixer" "-d" "5"; }
    XF86AudioMute        allow-when-locked=true { spawn "pamixer" "-t"; }
    XF86MonBrightnessUp   allow-when-locked=true { spawn "brightnessctl" "set" "+5%"; }
    XF86MonBrightnessDown allow-when-locked=true { spawn "brightnessctl" "set" "5%-"; }
    XF86AudioPlay  { spawn "playerctl" "play-pause"; }
    XF86AudioNext  { spawn "playerctl" "next"; }
    XF86AudioPrev  { spawn "playerctl" "previous"; }
}

window-rule {
    open-centered true
}

window-rule {
    match app-id="pavucontrol"
    open-floating true
}

window-rule {
    match app-id="nm-connection-editor"
    open-floating true
}
EOF

    # Create Pictures/Screenshots directory
    ensure_dir "${home_dir}/Pictures/Screenshots"

    # Copy dotfiles from nixup/dotfiles/
    local dotfiles_dir="${SCRIPT_DIR}/../dotfiles"

    # Ghostty config
    if [[ -d "${dotfiles_dir}/ghostty" ]]; then
        ensure_dir "${config_dir}/ghostty"
        cp "${dotfiles_dir}/ghostty/config" "${config_dir}/ghostty/config" 2>/dev/null || true
    fi

    # Git config
    if [[ -d "${dotfiles_dir}/git" ]]; then
        cp "${dotfiles_dir}/git/config" "${home_dir}/.gitconfig" 2>/dev/null || true
    fi

    # Yazi config
    if [[ -d "${dotfiles_dir}/yazi" ]]; then
        ensure_dir "${config_dir}/yazi"
        cp "${dotfiles_dir}/yazi/"*.toml "${config_dir}/yazi/" 2>/dev/null || true
    fi

    # Copy user scripts to ~/.local/bin
    local scripts_dir="${SCRIPT_DIR}/../scripts"
    local local_bin="${home_dir}/.local/bin"
    if [[ -d "${scripts_dir}" ]]; then
        ensure_dir "${local_bin}"
        for script in "${scripts_dir}"/*.sh; do
            if [[ -f "$script" ]]; then
                local script_name
                script_name=$(basename "$script" .sh)
                cp "$script" "${local_bin}/${script_name}"
                chmod +x "${local_bin}/${script_name}"
            fi
        done
        log_success "User scripts installed to ~/.local/bin"
    fi

    # Set ownership
    # Note: This will be done properly after nixos-install sets up the user
    log_success "User home configuration prepared"
}

# Main configuration generation function
generate_nixos_config() {
    log_step "4" "NixOS Configuration Generation"

    generate_hardware_configuration
    generate_configuration_nix
    copy_module_configs
    setup_home_config

    log_success "NixOS configuration complete!"
}

export -f generate_hardware_configuration generate_configuration_nix copy_module_configs
export -f generate_hardware_custom_nix setup_home_config generate_nixos_config
